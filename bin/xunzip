#!/usr/bin/env bash

# intuitive, simple unzip behaviour
# wraps 7z for core functionality

if [[ -z "$1" ]]
then
	echo "need an archive path"
	exit 1
fi

if (! type 7z > /dev/null 2>&1) && [[ -f '/c/Program Files/7-Zip/7z.exe' ]]
then
	# alias 7z='/c/Program Files/7-Zip/7z.exe'
	7z(){
		'/c/Program Files/7-Zip/7z.exe' "$@"
	}
fi

for archivePath in "$@"
do
	if [[ ! -f "$archivePath" ]]
	then
		echo "file does not exist: $archivePath"
		continue
	fi

	dirIn="$(dirname "$archivePath")"
	fullFileName="$(basename "$archivePath")"
	fileName="${fullFileName%.*}"
	ext="${archivePath#*.}"

	# handle ms office files
	if [[ "${ext,,}" =~ (xlsx|xlsm|pptx|docx) ]]
	then
		newExt="zip"
		newPath="$dirIn/${fileName}_${ext}.$newExt"
		mv "$archivePath" "$newPath"

		archivePath="$newPath"
		fullFileName="$(basename "$archivePath")"
		fileName="${fullFileName%.*}"
		ext="$newExt"
	fi

	# sanitize multiple dot file extension zips from the dir name
	dirName="$(echo "$fileName" | perl -pe 's/(\.pkg|\.tar|\.gz){1,3}$//g' | perl -pe 's/\.//g')"
	dirOut="$dirIn/$dirName"

	# # 7zip doesn't have zstd support
	# if [[ "${ext,,}" == "zst" ]]
	# then
	# 	if zstd -d "$archivePath"
	# 	then
	# 		rm "$archivePath"
	# 		archivePath="${archivePath%.*}"
	# 	fi
	# fi

	# unzip
	if 7z x -spe "-o$dirOut" -aos -- "$archivePath" | grep -i "extracting"
	then
		# if successful, delete the archive
		rm "$archivePath"
	fi

	# double unzip tar.* files
	# allow for leading dot for files like blah-x86_64.pkg.tar.zst
	if [[ "${ext,,}" =~ \.?tar\.[^\.]+$ ]]
	then
		tarPath="$(find "$dirOut" -type f -iname '*.tar' -print -quit)"

		if [[ -f "$tarPath" ]]
		then
			if "$HOME/bin/xunzip" "$tarPath"
			then
				# if unzip successful, move file contents one dir down and eliminate the extra directory
				tarOutDir="$(find "$dirOut" -maxdepth 1 -mindepth 1 -type d)"
				mv "$tarOutDir"/* "$dirOut"
				rm "$tarOutDir" -r
			fi
		fi
	fi

	subDirs="$(find "$dirOut" -maxdepth 1 -mindepth 1 -type d)"	
	subDirName="$(echo "$subDirs" | head -n1 | xargs -d '\n' basename)"

	# flatten identical sub dirs
	# TODO: handle dirOut renaming and match it to subDirs
	if [[ -n "$subDirs" && "$(echo "$subDirs" | wc -l)" -eq 1 && "$subDirName" -ef "$dirName" ]]
	then
		subDirPath="$dirOut/$subDirName"
		mv "$subDirPath/"* "$dirOut"
		rm -r "$subDirPath"
	fi

done
