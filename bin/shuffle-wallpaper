#!/usr/bin/env bash

titleText="Homescreen Wallpaper Updated"

optLockScreen=0
optFloater=0
optGlitch=0
optChillGlitch=0
optGreyscale=0
optNoNotify=0
optTerminal=0
optReadArgsFromCache=0
optOutPath=''
optNoModifyCache=0
optNextIsOutPath=0
optUnrecent=0
optVerbose=0
optCrop=0
reshuffleArgString=''

helpDeets="

shuffle-wallpaper [paths] [options]

paths: any list of files and directories. if called with no arguments, pulls cached paths from previous runs

  --lockscreen		target lockscreen instead of home screen
  --terminal		target terminal instead of home screen

  --glitch		use glitch-this to glitch the wallpaper first
  --chill-glitch	glitch, but less
  --grey		make color images greyscale
  --crop		auto-crop (most OS's will do this for you)
  --floater		center the design on black first
  --no-notify		don't notify (android only)
  --unrecent		do nothing if shuffled in the last 6 hours
  --help		display this help dialogue

  --output		copy the wallpaper somewhere; primarily for internal use
  --no-modify-cache	leave the cache at its previous values; primarily for internal use
"

glitchLevel(){

	# fractional glitch level if bc is installed
	if type bc >/dev/null 2>&1
	then
		echo "$(bc -l <<< "$(shuf -i 300-800 -n 1)/100")"
	else
		echo "$(shuf -i 3-8 -n 1)"
	fi
}

# TODO figure out aspect ratio
# TODO this really should be based on device resolution, not on aspect ratio
getTargetDimensions(){
	aspectRatio="9/20"
	path="$1"
	baseDim="${2:0:1}"

	if [[ -z "$path" || -z "$baseDim" ]]
	then
		echo "bad args to getTargetDimensions:" >&2
		echo "path: $path" >&2
		echo "baseDim: $baseDim" >&2
		exit 1
	fi

	if [[ "${baseDim,,}" == "w" ]]
	then
		width=$(identify -ping -format '%w' "$1")
		targetWidth="$width"
		targetHeight="$(echo "$width / ($aspectRatio)" | bc -l)"
	elif [[ "${baseDim,,}" == "h" ]]
	then
		height=$(identify -ping -format '%h' "$1")
		targetHeight="$height"
		targetWidth="$(echo "$height * ($aspectRatio)" | bc -l)"
	else
		echo "bad baseDim arg" >&2
		echo "baseDim: $baseDim" >&2
		exit 1
	fi

	# round using stupid shenanigans
	targetHeight="$(echo "($targetHeight + 0.5) / 1" | bc)"
	targetWidth="$(echo "($targetWidth + 0.5) / 1" | bc)"

	output="${targetWidth}x${targetHeight}"

	# echo "path: $path" >&2
	# echo "baseDim: $baseDim" >&2
	# echo "targetHeight: $targetHeight" >&2
	# echo "targetWidth: $targetWidth" >&2
	# echo "output: $output" >&2

	echo "$output"
}

for arg in "$@"
do
	if [[ "$arg" == "-h" || "$arg" == "--help" ]]
	then
		echo "$helpDeets"
		exit 0
	elif [[ "$arg" == "-l" || "$arg" == "--lockscreen" || "$arg" == "--lock" ]]
	then
		optLockScreen=1
		lockArg="-l"
		titleText="Lockscreen Wallpaper Updated"
		reshuffleArgString+="$arg "
	elif [[ "$arg" == "--floater" ]]
	then
		optFloater=1
		reshuffleArgString+="$arg "
	elif [[ "$arg" == "--no-notify" ]]
	then
		optNoNotify=1
	elif [[ "$arg" == "--terminal" ]]
	then
		optTerminal=1
		titleText="Terminal Wallpaper Updated"
		reshuffleArgString+="$arg "
	elif [[ "$arg" == "--glitch" ]]
	then
		optGlitch=1
	elif [[ "$arg" == "--chill-glitch" ]]
	then
		optGlitch=1
		optChillGlitch=1
	elif [[ "$arg" =~ \-\-gr[ae]y(scale)? ]]
	then
		optGreyscale=1
	elif [[ "$arg" == "--output" ]]
	then
		optNextIsOutPath=1
	elif [[ "$optNextIsOutPath" == "1" ]]
	then
		optOutPath="$arg"
		optNextIsOutPath=0
	elif [[ "$arg" == "--no-modify-cache" ]]
	then
		optNoModifyCache=1
	elif [[ "$arg" == "--unrecent" ]]
	then
		optUnrecent=1
	elif [[ "$arg" == "--verbose" || "$arg" == "-v" ]]
	then
		optVerbose=1
	elif [[ "$arg" == "--crop" ]]
	then
		optCrop=1
	elif [[ "${arg:0:1}" == "-" ]]
	then
		echo "I have no idea what $arg means"
		exit 1
	else
		# add to our arg array, thus filtering out valid options from paths
		args+=("$arg")
	fi
done

if [[ -n "$optOutPath" && ! -f "$optOutPath" ]]
then
	echo "output path does not exist"
	exit 1
fi

targetName="${OSTYPE}"
if [[ "$optTerminal" == 1 ]]
then
	targetName+="-term"
	optDefaultTarget=0
elif [[ "$optLockScreen" == 1 ]]
then
	targetName+="-lockscreen"
	optDefaultTarget=0
else
	targetName+="-default"
	optDefaultTarget=1
fi

if [[ "$OSTYPE" == "linux-android" ]]
then
	cacheDir="/data/data/com.termux/files/home/storage/shared/shuffle_wallpapers"
else
	cacheDir="$HOME/.cache/shuffle_wallpapers"
fi

mkdir -p "$cacheDir"

argCachePath="$cacheDir/args-${targetName}.log"
historyCachePath="$cacheDir/history-${targetName}.log"

# if unrecent arg is given
if [[ "$optUnrecent" == 1 ]]
then
	# then back out if the log was updated recently
	pastDate="$(date --date "8 hours ago" "+%s")"
	if [[ -f "$historyCachePath" ]]
	then
		logDate="$(stat -c "%Y" "$historyCachePath")"
	else
		logDate=0
	fi

	if [[ "$logDate" -gt "$pastDate" ]]
	then
		echo "wallpaper was updated recently. skipping"
		exit 0
	# else
	# 	echo "nah"
	# 	echo "historyCachePath: $historyCachePath"
	# 	echo "logDate: $logDate"
	# 	echo "pastDate: $pastDate"
	fi
fi

if [[ -z "$args" ]]
then
	if [[ -f "$argCachePath" ]]
	then
		args="$(cat "$argCachePath")"
	fi
	optReadArgsFromCache=1
else
	# convert paths to full paths here instead of downstream
	args="$(echo "$args" | xargs -d '\n' -I {} realpath "{}")"
fi

if [[ -z "$args" ]]
then
	echo "need wallpaper paths"
	exit 1
fi

topArg="$(echo "$args" | head -n 1)"

# TODO handle $args with both files and dirs together
if [[ ! -e "$topArg" ]]
then
	# echo "bad path"
	echo "bad path: $topArg"
	exit 1
elif [[ -d "$topArg" ]]
then
	files="$(echo "$args" | xargs -d '\n' -I {} find "{}" -type f -not -iname '*.md' -not -iname '*.html')"
else
	files="$args"
fi

baseFilesCount="$(echo "$files" | wc -l)"

# burn the history file if input paths have changed since last run
if [[ "$optNoModifyCache" == 0 && -f "$historyCachePath" && "$args" != "$(cat "$argCachePath")" ]]
then
	if [[ "$optVerbose" == 1 ]]
	then
		echo "burning history cache opt 1"
		echo "diff args: $args"
	fi

	rm "$historyCachePath"
# remove files from the list that have already been used
elif [[ "$optNoModifyCache" == 0 && -f "$historyCachePath" ]]
then
	filesMinusHistory="$(echo "$files" | grep -xiv -f "$historyCachePath")"
	newFilesCount="$(echo "$filesMinusHistory" | wc -l)"

	# update the var unless that would result in no files
	# then start the history over
	if [[ "$newFilesCount" -eq 1 && -z "$filesMinusHistory" ]]
	then
		if [[ "$optVerbose" == 1 ]]
		then
			echo "burning history cache opt 2"
		fi

		rm "$historyCachePath"
	else
		files="$filesMinusHistory"
	fi
fi

finalFilesCount="$(echo "$files" | wc -l)"
echo "total files to pick from: ${finalFilesCount}/${baseFilesCount}"

if [[ "$OSTYPE" == "msys" && -z "$optOutPath" ]] && [[ "$optLockScreen" == "1" || "$optDefaultTarget" == "1" ]]
then
	if [[ "$optDefaultTarget" == "1" ]]
	then
		winOutDir="$APPDATA/Microsoft/Windows/Themes"
		findIName="transcoded_*"
	elif [[ "$optLockScreen" == "1" ]]
	then
		winOutDir="$ProgramData/Microsoft/Windows/SystemData"
		findIName="lockscreen.*"
	fi

	winOutDir="$(cygpath "$winOutDir")"

	if [[ -z "$winOutDir" || ! -d "$winOutDir" ]]
	then
		echo "wallpaper folder cannot be found"
		exit 1
	fi

	# replace each wallpaper in the wallpaper dir
	outPaths="$(find "$winOutDir" -type f -iname "$findIName")"

	echo "$outPaths" | while read -r outPath
	do
		"$0" "$@" --output "$outPath"
	done

	# reload wallpapers
	RUNDLL32.EXE USER32.DLL,UpdatePerUserSystemParameters ,1 ,True

	exit 0

fi

paperPath="$(echo "$files" | shuf --random-source='/dev/urandom' -n 1)"
basePaperPath="$paperPath"
paperFileName="$(basename "$paperPath")"
modDir="$cacheDir/mods"
if type magick > /dev/null 2>&1
then
	magick="magick"
else
	magick="convert"
fi

if [[ "$optGlitch" == "1" ]]
then
	if type glitch_this >/dev/null 2>&1
	then
		mkdir -p "$modDir"
		paperFileName="$(basename "$paperPath")"
		paperPathMod="$modDir/glitched_$paperFileName"

		if [[ "$optChillGlitch" = 1 ]]
		then
			glitch_this -c -f -o "$paperPathMod" "$paperPath"         2 > /dev/null
			glitch_this    -f -o "$paperPathMod" "$paperPathMod" 1 > /dev/null
			glitch_this    -f -o "$paperPathMod" "$paperPathMod" 1 > /dev/null
		else
			glitch_this -c -f -o "$paperPathMod" "$paperPath"         $(glitchLevel) > /dev/null
			glitch_this -c -f -o "$paperPathMod" "$paperPathMod" $(glitchLevel) > /dev/null
			glitch_this -c -f -o "$paperPathMod" "$paperPathMod" $(glitchLevel) > /dev/null
		fi

		paperPath="$paperPathMod"
		paperFileName="$(basename "$paperPath")"
	else
		echo "glitch_this is not installed"
	fi
fi

if [[ "$optGreyscale" == "1" ]]
then
	if type $magick >/dev/null 2>&1
	then
		mkdir -p "$modDir"
		paperFileName="$(basename "$paperPath")"
		paperPathMod="$modDir/grey_$paperFileName"

		$magick "$paperPath" -colorspace Gray "$paperPathMod"

		paperPath="$paperPathMod"
		paperFileName="$(basename "$paperPath")"
	else
		echo "imagemagick not installed"
	fi
fi

# TODO once we've handled the aspect ratio / resolution TODO merge crop and floater handling
if [[ "$optFloater" == "1" ]]
then
	if type identify >/dev/null 2>&1 && type $magick >/dev/null 2>&1
	then
		targetDimensions="$(getTargetDimensions "$paperPath" "width")"
		echo "cropping to $targetDimensions"

		mkdir -p "$modDir"
		paperFileName="$(basename "$paperPath")"
		paperPathMod="$modDir/resized_$paperFileName"

		$magick -background "black" -gravity Center "$paperPath" -extent "$targetDimensions" +repage "$paperPathMod"

		paperPath="$paperPathMod"
		paperFileName="$(basename "$paperPath")"
	else
		echo "imagemagick not installed"
	fi
fi

if [[ "$optCrop" == "1" ]]
then
	if type identify >/dev/null 2>&1 && type $magick >/dev/null 2>&1
	then
		targetDimensions="$(getTargetDimensions "$paperPath" "height")"
		echo "cropping to $targetDimensions"

		mkdir -p "$modDir"
		paperFileName="$(basename "$paperPath")"
		paperPathMod="$modDir/crop_$paperFileName"

		$magick -background "black" -gravity Center "$paperPath" -extent "$targetDimensions" +repage "$paperPathMod"

		paperPath="$paperPathMod"
		paperFileName="$(basename "$paperPath")"
	else
		echo "imagemagick not installed"
	fi
fi

if [[ -n "$optOutPath" ]]
then
	cp "$paperPath" "$optOutPath"
elif [[ "$OSTYPE" == "msys" && "$optTerminal" == 1 ]]
then
	wtDir="$(find "${LOCALAPPDATA}/Packages/" -maxdepth 2 -wholename "*WindowsTerminal*" -name LocalState -print -quit)"
	settingsPath="${wtDir}/settings.json"
	if [[ ! -d "$wtDir" || ! -f "$settingsPath" ]]
	then
		echo "cannot find windows terminal settings"
		exit 1
	fi

	wtPaperPath="$paperPath"
	# swap unix to windows path
	if type cygpath >/dev/null 2>&1
	then
		wtPaperPath="$(cygpath -w "$wtPaperPath")"
	fi
	# escape once for windows terminal and once for the perl command below
	wtPaperPath="$(echo "$wtPaperPath" | sed -e 's/\\/\\\\/g' -e 's/\\/\\\\/g')"

	# update the path in the windows terminal settings file
	perl -pi -e "s|(?<=^\s{1,50}\"backgroundImage\": ?\")[^\"]+(?=\",?$)|$wtPaperPath|g" "$settingsPath"
elif [[ "$OSTYPE" == "linux-android" ]]
then
	termux-wallpaper $lockArg -f "$paperPath"
	termux-media-scan "$paperPath"
elif [[ "$OSTYPE" == "linux-gnu" ]] && type xfconf-query >/dev/null 2>&1
then
	if [[ "$optTerminal" == "1" ]]
	then
		xfconf-query -c xfce4-terminal -p /background-image-file -s "$paperPath"
	elif [[ "$optLockScreen" == "1" ]]
	then
		echo "what xfconf-query command changes the lockscreen wallpaper?"
		exit 1
	else
		# TODO support all monitors
		xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitorHDMI-1/workspace0/last-image -s "$paperPath"
	fi
elif [[ "$OSTYPE" == "linux-gnu" ]] && type xfconf-query >/dev/null 2>&1
then
	echo "non-xfce linux not yet supported"
	exit 1
else
	echo "OS $OSTYPE not yet supported"
	exit 1
fi

if [[ "$optNoModifyCache" == 0 && "$optReadArgsFromCache" == 0 ]]
then
	# cache paths
	echo "$args" > "$argCachePath"
fi

echo "$paperFileName"
# have to cache the *original* paper path, regardless of modifications after the fact
echo "$basePaperPath" >> "$historyCachePath"

# notify if appropriate and possible
if [[ "$optNoNotify" == "0" ]]
then
	if [[ -f "$HOME/bin/git-file-url" ]]
	then
		sharePath="$("$HOME/bin/git-file-url" "$paperPath" --raw)"
	fi

	if [[ -z "$sharePath" ]]
	then
		sharePath="$paperPath"
	fi

	if [[ "$OSTYPE" == "linux-android" ]]
	then
		# elaborate notification with actions to take
		reshuffleAction="\"$HOME/bin/shuffle-wallpaper\" $reshuffleArgString"
		logPath="$HOME/.logs/shuffle-wallpaper-action.log"

		# if reshuffleArgString contained paths we would have to wrap them in quotes within the string
		# as the action commands seemed to be stored as strings and the distinction between parameters is lost
		# instead of using paths, reshuffle makes use of the cache to use the previous args as last time
		# the other two actions leave the cache unmodified so that "reshuffle" still works
		# as does manually shuffling with no path args

		termux-notification --image-path "$paperPath" --title "$titleText" --content "$paperFileName" --group "shuffle-wallpaper" --id "$titleText" \
			--action "termux-open \"$paperPath\" && termux-clipboard-set \"$sharePath\" > \"$logPath\" 2>&1" \
			--button1 "reshuffle" \
			--button1-action "$reshuffleAction > \"$logPath\" 2>&1"\
			--button2 "greyscale" \
			--button2-action "\"$HOME/bin/shuffle-wallpaper\" --no-modify-cache --grey $lockArg \"$paperPath\" > \"$logPath\" 2>&1" \
			--button3 "glitch" \
			--button3-action "\"$HOME/bin/shuffle-wallpaper\" --no-modify-cache --glitch $lockArg \"$paperPath\" > \"$logPath\" 2>&1" \
			--icon 'wallpaper'

	fi
fi
