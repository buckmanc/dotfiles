#!/usr/bin/env bash

set -e

optForce=0
optQuiet=0
optDeleteSource=0
optNoDeleteOld=0
optDryRun=0
optTestImage=0
optCrf=24
optNextIsCrf=0
files=()

for arg in "$@"
do
	if [[ -z "$arg" ]]
	then
		continue
	fi

	if [[ "$optNextIsCrf" == 1 ]]
	then
		optCrf="$arg"
		optNextIsCrf=0
	elif [[ "$arg" =~ \-\-?f(orce)? ]]
	then
		optForce=1
	elif [[ "$arg" =~ \-\-?q(uiet)? ]]
	then
		optQuiet=1
	elif [[ "$arg" == "--delete" ]]
	then
		optDeleteSource=1
	elif [[ "$arg" == "--no-delete" || "$arg" == "--no-delete-old" ]]
	then
		optNoDeleteOld=1
	elif [[ "$arg" == "--dry-run" ]]
	then
		optDryRun=1
	elif [[ "$arg" =~ \-\-test(\-image)? ]]
	then
		optTestImage=1
	elif [[ "$arg" == "--crf" ]]
	then
		optNextIsCrf=1
	elif [[ "$arg" == -* ]]
	then
		echo "i have no clue what $arg means"
		exit 1
	elif [[ -d "$arg" ]]
	then
		# if we got a directory, grab any video files therein
		# using file extensions instead of deeper inspection for performance
		dirfiles="$(find "$arg" -type f -not -ipath '*/.git/*' -not -ipath '*/.internals/*' -regextype posix-extended -iregex '.+\.(mp4|3gp|avi|mpeg|mov|mkv|mpg|wmv|webm|ogv|avchd)' -size +0 | sort)"

		while read -r dirFile
		do
			files+=("$dirFile")
		done < <(echo "$dirfiles")

	elif [[ -f "$arg" ]]
	then
		files+=("$arg")
	else
		echo "I have no idea what $arg means"
		exit 1
	fi
done

if [[ "${#files[@]}" -lt 1 ]]
then
	echo "need at least one file path"
	exit 1
fi

# use a package to parse the output if available
if type ffmpeg-progress-yield > /dev/null 2>&1
then
	progress="ffmpeg-progress-yield --progress"
else
	progress=""
fi

# lower crf number is high quality
# requires experimentation to find "visual losslessnes"
codec=H264
preset=slower
testTimeStamp="0:07"
formatRegex="[ _\-]{1,3}H26\d[ _]CRF[ _]\d{1,2}\.mp4$"

# stackoverflow.com/a/296135731995812
quoteRe() {
	sed -e 's/[^^]/[&]/g; s/\^/\\^/g; $!a\'$'\n''\\n' <<<"$1" | tr -d '\n'
}

makeTestImage(){
	testSource="$1"
	testDest="$2"
	if [[ "$optTestImage" == 1 ]]
	then
		# skip test image in case of failure
		if [[ ! -f "$testSource" ]]
		then
			return
		fi

		if [[ "$optDryRun" == 0 ]]
		then
			ffmpeg -i "$testSource" -ss "$testTimeStamp" -vframes 1 -y -loglevel error "$testDest"
		else
			echo "would have written $(basename "$testDest")"
		fi
	fi
}

for src in "${files[@]}"
do
	if [[ -z "$src" ]]
	then
		continue
	fi

	destDir="$(dirname "$src")"
	srcFileName="$(basename "$src")"

	srcExt="${src##*.}"
	srcExt="${srcExt,,}"
	srcFileNameNoExt="${srcFileName%.*}"
	srcFileNameNoExtTrim="${srcFileNameNoExt% - Raw}"

	dupeCheckPath="$destDir/${srcFileNameNoExt}."
	dupeCheckPath="$(echo "$dupeCheckPath" | perl -pe 's|^\./||g')"
	# echo "dupeCheckPath: $dupeCheckPath"
	# echo "files:"
	# printf '%s\n' "${files[@]}"

	dupeCheckCount="$(printf '%s\n' "${files[@]}" | perl -pe 's|^\./||g' | grep -Fc "$dupeCheckPath")"

	# if there is likely to be an output collision, add the source file ext to the filename
	if [[ "$dupeCheckCount" -ge 2 ]]
	then
		dupeClause="${srcExt}_"
	else
		dupeClause=""
	fi

	destFileNameNoExt="${srcFileNameNoExtTrim}_${codec}_${dupeClause}CRF_$optCrf"
	destFileName="$destFileNameNoExt.mp4"
	destPath="$destDir/$destFileName"

	destFileNameOldNoExt="${srcFileNameNoExtTrim} - ${codec} CRF $optCrf"
	destFileNameOld="$destFileNameOldNoExt.mp4"
	destPathOld="$destDir/$destFileNameOld"

	if echo "$srcFileName" | grep -Piq "$formatRegex"
	then
		if [[ "$optQuiet" == 0 ]]
		then
			echo "skipping prior output file: $srcFileNameNoExt"
		fi
		continue
	fi

	skippySkip=0
	if [[ -f "$destPath" || -f "$destPathOld" ]] && [[ "$optForce" == 0 ]]
	then
		skippySkip=1
	fi

	if [[ "$skippySkip" == 1 ]]
	then
		if [[ "$optQuiet" == 0 ]]
		then
			# sucks to check it again but alas
			if [[ -f "$destPath" ]]
			then
				echo "already exists: $destFileNameNoExt"
			else
				echo "already exists: $destFileNameOldNoExt"
			fi
		fi
	fi

	srcFileBaseRegex="$(quoteRe "$srcFileNameNoExtTrim")$formatRegex"

	otherOutputFiles="$(find "$destDir" -type f -iname "${srcFileNameNoExtTrim}*" -not -iname "${destFileNameNoExt}*" -not -iname "${destFileNameOldNoExt}*" | grep -iP "$srcFileBaseRegex" || true)"

	if [[ "$optNoDeleteOld" == 0 ]]
	then
		while read -r fileToBurn
		do
			if [[ -z "$fileToBurn" ]]
			then
				continue
			fi

			if [[ "$optDryRun" == 0 ]]
			then
				rm "$fileToBurn"
			else
				echo "would have deleted $(basename "$fileToBurn")"
			fi
		done < <(echo "$otherOutputFiles")
	fi

	testPathSource="$destDir/$srcFileNameNoExt.png"
	testPathDest="$destDir/$destFileNameNoExt.png"

	if [[ "$skippySkip" == 1 ]]
	then
		: # no op
	elif [[ "${codec^^}" == "H264" ]]
	then
		if [[ "$optDryRun" == 0 ]]
		then
			$progress ffmpeg -hide_banner -i "$src" -vcodec libx264 -crf "$optCrf" -vf yadif=1 -c:a aac -preset "$preset" "$destPath" || true

			rm -rf "$testPathDest"
		else
			echo "would have written $destFileNameNoExt"
		fi

		makeTestImage "$destPath" "$testPathDest"
	elif [[ "${codec^^}" == "H265" ]]
	then
		if [[ "$optDryRun" == 0 ]]
		then
			$progress ffmpeg -hide_banner -i "$src" -vcodec libx265 -crf "$optCrf"-tag:v hvc1 -vf yadif=1 -c:a aac -preset "$preset" "$destPath" || true

			rm -rf "$testPathDest"
		else
			echo "would have written $destFileNameNoExt"
		fi

		makeTestImage "$destPath" "$testPathDest"
	else
		echo "unknown codec"
		exit 1
	fi

	# write a couple test images to compare quality
	if [[ ! -f "$testPathSource" || "$optForce" == 1 ]]
	then
		makeTestImage "$src" "$testPathSource"
	fi

	# do this part even if skipping
	if [[ "$optDeleteSource" == 1 ]]
	then
		if [[ "$optDryRun" == 1 ]]
		then
			echo "would have deleted $srcFileNameNoExt"
		# only delete if the destination file exists and isn't empty
		elif [[ -s "$destPath" ]]
		then
			rm "$src"
		fi
	fi

done

