#!/usr/bin/env bash

set -e

# TODO search by game title rather than game code

repoPath="$TEMP/death_generator"
tempDir="$TEMP/deathstitch_generator"
textTempPath="$tempDir/text.png"
qrTempPath="$tempDir/qr.png"
tempOutPath="$tempDir/output.png"
repoUrl="https://github.com/foone/SierraDeathGenerator"
borderDir="$(dirname "$0")/deathstitch_borders"

labelFontPoints=60
labelFontLines=5 # needs to be manually updated if changed
qrSize="$(echo "$labelFontPoints * $labelFontLines * 1.3333" | bc -l | perl -pe 's/\.\d+$//g')"

optGame=""
optSubFont=""
optText=""
optOutPath=""
optSize=""
optVerbose=0
optBorder=""
optQrUrl='https://github.com/buckmanc/dotfiles/blob/main/bin/deathstitch-generator'
optImagePath=""

for arg in "$@"
do
	if [[ -z "$arg" ]]
	then
		continue
	fi

	if [[ "$optNextIsGame" == 1 ]]
	then
		optGame="$arg"
		optNextIsGame=0
	elif [[ "$optNextIsSubFont" == 1 ]]
	then
		optSubFont="$arg"
		optNextIsSubFont=0
	elif [[ "$optNextIsText" == 1 ]]
	then
		optText="$arg"
		optNextIsText=0
	elif [[ "$optNextIsOutPath" == 1 ]]
	then
		optOutPath="$arg"
		optNextIsOutPath=0
	elif [[ "$optNextIsBorder" == 1 ]]
	then
		optBorder="$arg"
		optNextIsBorder=0
	elif [[ "$optNextIsQrUrl" == 1 ]]
	then
		optQrUrl="$arg"
		optNextIsQrUrl=0
	elif [[ "$optNextIsImagePath" == 1 ]]
	then
		optImagePath="$arg"
		optNextIsImagePath=0
	elif [[ "$arg" == "-v" || "$arg" == "--verbose" ]]
	then
		optVerbose=1
	elif [[ "$arg" == "--game" || "$arg" == "--font" ]]
	then
		optNextIsGame=1
	elif [[ "$arg" == "--subfont" ]]
	then
		optNextIsSubFont=1
	elif [[ "$arg" == "--text" ]]
	then
		optNextIsText=1
	elif [[ "$arg" == "--outpath" ]]
	then
		optNextIsOutPath=1
	elif [[ "$arg" == "--border" ]]
	then
		optNextIsBorder=1
	elif [[ "$arg" == "--qr" ]]
	then
		optNextIsQrUrl=1
	elif [[ "$arg" == "--image" ]]
	then
		optNextIsImagePath=1
	elif [[ "$arg" =~ [0-9]+[xX][0-9]+ ]]
	then
		optSize="$arg"
	else
		echo "I have no idea what $arg means"
		exit 1
	fi
done

if [[ -z "$optGame" || -z "$optText" || -z "$optOutPath" ]]
then
	echo "need --game, --text, and --outpath"
	exit 1
fi

if [[ -n "$optBorder" ]]
then
	if [[ ! -d "$borderDir" ]]
	then
		echo "border directory not found:"
		echo "$borderDir"
		exit 1
	fi

	# not perfect but should suffice
	if [[ "$optBorder" =~ ^[0-9]+$ ]]
	then
		optBorder="_${optBorder}"
	fi

	optBorderPath="$(find "$borderDir" -type f -iname "*${optBorder}*" -not -iname '*center*' | head -n1)"
	optCenterBorderPath="$(find "$borderDir" -type f -iname "*${optBorder}*" -iname '*center*' | head -n1)"

	if [[ -z "$optBorderPath" ]]
	then
		echo "no matching border found in $borderDir"
		exit 1
	fi
fi

if [[ -n "$optImagePath" && ! -f "$optImagePath" ]]
then
	echo "image path does not exist:"
	echo "$optImagePath"
	exit 1
fi

# imagemagick version compatibility
if type magick >/dev/null 2>&1
then
	magick=magick
elif type convert >/dev/null 2>&1
then
	magick=convert
else
	echo 'imagemagick not installed'
	exit 1
fi

if ! type json_repair >/dev/null 2>&1
then
	echo 'json_repair not installed'
	echo 'run pip install json-repair'
	exit 1
fi

if [[ -d "$repoPath/.git" ]]
then
	# TODO smooth out probs
	git -C "$repoPath" pull > /dev/null
else
	git clone "$repoUrl" "$repoPath"
	echo
fi

outDir="$(dirname "$optOutPath")"
outFullFileName="$(basename "$optOutPath")"
outFileName="${outFullFileName%%.*}"
outExt="${outFullFileName##*.}"
if [[ "${outExt,,}" != "png" ]]
then
	outExt="png"
	optOutPath="$outDir/${outFileName}.$outExt"
fi

outPatternFullFileName="${outFileName}_pattern.${outExt}"
outPatternPath="$outDir/$outPatternFullFileName"

echo "file:     ${outFileName%.**}"

mkdir -p "$outDir"
mkdir -p "$tempDir"

# only game dirs with a json config file
# they *can* have multiple config files, but only one game does
gamesList="$(find "$repoPath/games/" -type f -iname '*.json' -not -ipath '*/tests/*' -not -ipath '*/tools/*' | sort | xargs dirname | xargs -L 1 -d '\n' basename | uniq)"
matchingGame="$(echo "$gamesList" | grep -i "$optGame" || true)"

# echo "asdfasdf: $optGame"

if [[ "$(echo "$matchingGame" | wc -l)" -gt 1 ]]
then
	echo "found too many matches. limiting to exact matches instead of contains..."
	matchingGame="$(echo "$matchingGame" | grep -Fix "$optGame" || true)"
fi

if [[ -z "$matchingGame" ]]
then
	echo "no matching games found"
	exit 1
elif [[ "$(echo "$matchingGame" | wc -l)" -gt 1 ]]
then
	echo "found too many matches"
	echo "$matchingGame"
	exit 1
fi

# use the javascript generators details and use json_repair to convert it to json for deets
gameDeetsJson="$(cat "$repoPath/js/generators.js" | head -n -1 | tail -n +2 | grep -iv 'defaulttext' | json_repair | jq ". | to_entries[] | select(.key == \"$matchingGame\").value")"

if [[ -n "$gameDeetsJson" && "$gameDeetsJson" != "null" ]]
then
	gameTitle="$(echo "$gameDeetsJson" | jq '.title + " (" + (.year | tostring) + ")"')"
else
	gameTitle="$matchingGame"
fi

echo "game:     $matchingGame"

# TODO handle multiple json config files
# so far there's only one game that has multiple
gameDirPath="$repoPath/games/$matchingGame/"
gameConfigJsonPath="$(find "$gameDirPath" -maxdepth 1 -type f -iname '*.json' | head -n 1)"
gameFontImagePath="$(find "$gameDirPath" -maxdepth 1 -type f -iname '*-font.png' | head -n 1)"

gameConfigJson="$(cat "$gameConfigJsonPath")"
subFontsJson="$(echo "$gameConfigJson" | jq -c '.subfonts')"

if [[ -n "$optSubFont" ]]
then
	if [[ -z "$subFontsJson" || "$subFontsJson" == "null" ]]
	then
		echo "game has no subfonts"
		exit 1
	fi

	kvp="$(echo "$subFontsJson" | jq -c "to_entries.[] | select(.key | contains(\"$optSubFont\"))" | head -n1)"
	fontName="$(echo "$kvp" | jq -r '.key')"
	fontConfigJson="$(echo "$kvp" | jq -r '.value')"

	if [[ -n "$fontConfigJson" && -n "$fontName" ]]
	then
		echo "found subfont $fontName"
	else
		echo "could not find subfont $optSubFont"
		exit 1
	fi
else
	fontConfigJson="$gameConfigJson"
	
	if [[ -n "$subFontsJson" && "$subFontsJson" != null ]]
	then
		otherFonts="$(echo "$subFontsJson" | jq 'to_entries.[].key' -r)"
		
		if [[ -n "$otherFonts" ]]
		then
			echo "  possible subfonts:"
			echo "$otherFonts" | perl -pe 's/^/  /g'
		fi
	fi
fi

if [[ "$optVerbose" == 1 ]]
then
	echo "gameConfigJsonPath: $gameConfigJsonPath"
fi

defaultX="$(echo "$fontConfigJson" | jq -r '.default.x // 0')"
defaultY="$(echo "$fontConfigJson" | jq -r '.default.y // 0')"
defaultW="$(echo "$fontConfigJson" | jq -r '.default.w // 0')"
defaultH="$(echo "$fontConfigJson" | jq -r '.default.h // 0')"
lineHeight="$(echo "$fontConfigJson" | jq -r '.height // 0')"

# TODO check the font config json as well
nullCharCode="$(echo "$gameConfigJson" | jq -r '."null-character" // 32')"
nullCharJson="$(echo "$fontConfigJson" | jq -rc ".\"$nullCharCode\"")"
caseFold="$(echo "$fontConfigJson" | jq -r '."case-fold"')"

i=0
magickTextArgs=()
magickTextArgs+=("$magick -background none")

if [[ -n "$optImagePath" ]]
then
	magickTextArgs+=("\( $optImagePath -background transparent -gravity south -splice 0x5 \)")
	optImageWidth="$(identify -format '%w' "$optImagePath")"
fi

# colorize the text as best as we can
magickLineColorArgs=()
if [[ "$matchingGame" =~ (ff5|fft|mmx1|sth2) ]]
then
	magickLineColorArgs=("-fill grey -opaque white")
elif [[ "$matchingGame" =~ (lttp) ]]
then
	magickLineColorArgs=("-transparent white -fill black -colorize 100")
# elif [[ "$matchingGame" =~ (goku2|minishcap) ]]
# then
else
	magickLineColorArgs=("-fill black -colorize 100")
fi

# appending chars horizontally to make lines
# appending lines vertically to make the text

while read -r line
do
	i=$((i+1))

	if [[ "$caseFold" == "upper" ]]
	then
		line="${line^^}"
	fi

	chars="$(echo "$line" | sed -e 's/\(.\)/\1\n/g')"
	lineOutPath="$tempDir/$i.png"

	magickTextArgs+=("$lineOutPath")

	magickLineArgs=()
	magickLineArgs+=("$magick $gameFontImagePath -background none")

	if [[ "$optVerbose" == 1 ]]
	then
		echo "line: $line"
		# echo "chars: $chars"
	fi

	while read -r char
	do
		if [[ -z "$char" ]]
		then
			char=" "
		fi

		charCode="$(echo -n "$char" | od -An -td1 -w1 -v | perl -pe 's/( +$|^ +)//g')"
		charJson="$(echo "$fontConfigJson" | jq -rc ".\"$charCode\"")"

		if [[ "$optVerbose" == 1 ]]
		then
			echo "char: $char $(printf "%*s" "3" "$charCode") $charJson"
		fi

		if [[ -z "$charJson" || "$charJson" == "null" ]]
		then
			charJson="$nullCharJson"
		fi

		charX="$(echo "$charJson" | jq -rc ".x // $defaultX")"
		charY="$(echo "$charJson" | jq -rc ".y // $defaultY")"
		charW="$(echo "$charJson" | jq -rc ".w // $defaultW")"
		charH="$(echo "$charJson" | jq -rc ".h // $defaultH")"

		magickLineArgs+=("\( -clone 0 -crop ${charW}x${charH}+${charX}+${charY} +repage \)")

	done < <( echo "$chars" )

	magickLineArgs+=("-delete 0")
	magickLineArgs+=("+append +repage -extent 'x${lineHeight}<'")
	magickLineArgs+=( "${magickLineColorArgs[@]}" )
	magickLineArgs+=("$lineOutPath")

	if [[ "$optVerbose" == 1 ]]
	then
		echo "magickLineArgs: ${magickLineArgs[*]}"
	fi

	eval "${magickLineArgs[*]}"

	# if optImagePath exists, make sure the line image has the same even/oddness as the optImage
	# if not, add one pixel to the line width
	# keeps the image centered
	if [[ -r "$optImagePath" ]]
	then
		lineWidth="$(identify -format '%w' "$lineOutPath")"

		if ((optImageWidth % 2 != lineWidth % 2))
		then

			if [[ "$optVerbose" == 1 ]]
			then
				echo "adjusting line width"
				echo "lineWidth: $lineWidth, optImageWidth: $optImageWidth, lineIndex: $i"
			fi

			"$magick" "$lineOutPath" \
				\( -size "1x${lineHeight}" xc:transparent \) \
				+append "$lineOutPath"

			lineWidth="$(identify -format '%w' "$lineOutPath")"

			if [[ "$optVerbose" == 1 ]]
			then
				echo "new lineWidth: $lineWidth"
			fi
		fi
	fi

done < <( echo "$optText" )

# TODO do a vertical trim here
# not a side to side trim; that will mess with the parity centering adjustments
magickTextArgs+=("-gravity center -append $textTempPath")

if [[ "$optVerbose" == 1 ]]
then
	echo "magickTextArgs: ${magickTextArgs[*]}"
fi

# render the text
eval "${magickTextArgs[*]}"

# calculate border dimensions
if [[ -n "$optBorderPath" ]]
then

	borderDim="$(identify -format '%wx%h' "$optBorderPath")"
	borderWidth="$( echo "$borderDim" | cut -d 'x' -f 1)"
	borderHeight="$(echo "$borderDim" | cut -d 'x' -f 2)"
fi

# if not given a size but given a border path
# then calculate a canvas size based on text size + border size
if [[ -z "$optSize" && -n "$optBorderPath" ]]
then
	textDim="$(identify -format '%wx%h' "$textTempPath")"
	textWidth="$( echo "$textDim" | cut -d 'x' -f 1)"
	textHeight="$(echo "$textDim" | cut -d 'x' -f 2)"

	# keep the text width even to assure symbols are centered
	# TODO check symbol and/or center border parity first and match to that instead
	# maybe only match if they're the same
	# maybe create a var to determine if centering adjustments are necessary
	# and check that here and at the text line adjustment
	if (( ( textWidth + borderWidth ) % 2 == 0 ))
	then
		widthParityAdj=0
	else
		widthParityAdj=1
	fi

	optSize="$((textWidth + borderWidth + widthParityAdj))x$((textHeight + borderHeight))"
fi

# slap it on a canvas if given a size for one
if [[ -n "$optSize" ]]
then
	"$magick" \( -size "$optSize" xc:transparent \) "$textTempPath" -gravity center -composite "$tempOutPath"
# otherwise just run with what we got
else
	cp "$textTempPath" "$tempOutPath"
fi

	outputDim="$(identify -format '%wx%h' "$tempOutPath")"
	outputWidth="$( echo "$outputDim" | cut -d 'x' -f 1)"
	outputHeight="$(echo "$outputDim" | cut -d 'x' -f 2)"

# you can provide the top left corner as a border
# this is then flip/flopped to all corners and edge pixels are stretched between the corners
# top/bottom center embellishments can also be provided
if [[ -n "$optBorderPath" ]]
then
	fillerWidth=$((outputWidth - borderWidth - borderWidth))
	fillerHeight=$((outputHeight - borderHeight - borderHeight))

	fillerTopPath="$tempDir/filler_top.png"
	fillerSidePath="$tempDir/filler_side.png"

	# create border fillers by stretching the final pixels of the corners
	"$magick" "$optBorderPath" -gravity northeast -crop 1x+0-0 +repage -scale "${fillerWidth}x!" "$fillerTopPath"
	"$magick" "$optBorderPath" -gravity southwest -crop x1+0-0 +repage -scale "x${fillerHeight}!" "$fillerSidePath"

	# TODO calculate the amount to trim borders if the canvas is too small
	# if fillerW/H is negative, remove (abs(fillerW/H) / 2) from the border
	# could also increase fillerWidth to make sure the center thing is preserved
	# but the juice is probably not worth the squeeze for these

	# support optional little embellishments on the top and bottom of the border
	if [[ -n "$optCenterBorderPath" ]]
	then
		"$magick" "$fillerTopPath" "$optCenterBorderPath" "$fillerTopPath" -background none -gravity north +append +repage -extent "${fillerWidth}" "$fillerTopPath"
	fi

	# add the borders in the corners and the filler between them
	"$magick" "$tempOutPath" \
		\( "$optBorderPath"				\) -gravity northwest	-composite \
		\( "$optBorderPath" -flop		\) -gravity northeast	-composite \
		\( "$optBorderPath" -flip		\) -gravity southwest	-composite \
		\( "$optBorderPath" -flip -flop	\) -gravity southeast	-composite \
		\( "$fillerTopPath"				\) -gravity north		-composite \
		\( "$fillerTopPath" -flip		\) -gravity south		-composite \
		\( "$fillerSidePath"			\) -gravity west		-composite \
		\( "$fillerSidePath" -flop		\) -gravity east		-composite \
		"$tempOutPath"
fi

cp "$tempOutPath" "$optOutPath"


inchesWidth="$(echo "scale=2; $outputWidth / 14" | bc -l)"
inchesHeight="$(echo "scale=2; $outputHeight / 14" | bc -l)"

if [[ "$inchesWidth" == *"."* ]]
then
	inchesWidth="$(echo "$inchesWidth" | perl -p -e 's/0+$//g;' -e 's/\.$//g;')"
fi

if [[ "$inchesHeight" == *"."* ]]
then
	inchesHeight="$(echo "$inchesHeight" | perl -p -e 's/0+$//g;' -e 's/\.$//g;')"
fi

stitchesDim="${outputWidth} x ${outputHeight}"
inchesDim="${inchesWidth}\" x ${inchesHeight}\""

echo "stitches: $stitchesDim"
echo "inches:   $inchesDim"

# generate a tiny one-to-one qr code
echo "$optQrUrl" | qrencode --size 1 --margin 1 --output "$qrTempPath"

# TODO extract all of this to a separate script that can be run on manually created/altered pixel images to turn them into cross stitch patterns
# TODO add grid lines with thicker lines every x
# TODO build line args, then you can count the array elements update the line count arg for the qr code size calculation
"$magick" \
	"$tempOutPath" -interpolate integer -filter point -resize "1500x1500^<" \
	\( -background transparent -pointsize "$labelFontPoints" -fill black label:"stitches: $outputDim" \) \
	\( -background transparent -pointsize "$labelFontPoints" -fill black label:"inches: $inchesWidth\" x $inchesHeight\" (with 14 ct Aida)" \) \
	\( -background transparent -pointsize "$labelFontPoints" -fill black label:"font: $gameTitle" \) \
	\( -background transparent -pointsize "$labelFontPoints" -fill black label:"font sourced from death generator" \) \
	\( -background transparent -pointsize "$labelFontPoints" -fill black label:"pattern made with deathstitch generator" \) \
	-append +repage \
	\( "$qrTempPath" -interpolate integer -filter point -resize "${qrSize}x${qrSize}<" \) \
	-gravity southeast -composite \
	-background white -alpha remove -bordercolor white -border 20 "$outPatternPath"

echo "done!"
echo
