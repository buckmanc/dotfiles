#!/usr/bin/env bash

# TODO
# test
# accept files list or dirs
# wrap with git-fix-source-file

# this script uses perl instead of sed because
# - perl has better regex support
# - sed was inconsistently duplicating the file with an added 'r' at the end of the filename

optTw=0
optCarriageReturn=0
optCommentSpacing=0
optTab=0
files=()

argsFound=0
args=("$@")
for arg in "${args[@]}"
do
	if [[ "$arg" == "-"* ]]
	then
		argsFound=1
	fi
done

# default to "all" if no args are provided
if [[ "$argsFound" == 0 ]]
then
	args+=("--all")
fi

for arg in "${args[@]}"
do
	if [[ "$arg" == "--tw" || "$arg" == "--trailing-whitespace" || "$arg" == "-w" ]]
	then
		optTw=1
	elif [[ "$arg" == "--nl" || "$arg" == "-l" || "$arg" == "--carriage-return" || "$arg" == "--cr" ]]
	then
		optCarriageReturn=1
	elif [[ "$arg" == "--tab" || "$arg" == "-t" ]]
	then
		optTab=1
	elif [[ "$arg" == "--comment" || "$arg" == "-c" ]]
	then
		optCommentSpacing=1
	elif [[ "$arg" == "--all" || "$arg" == "-a" ]]
	then
		optTw=1
		optCarriageReturn=1
		optTab=1
		optCommentSpacing=1
	elif [[ "$arg" == "-"* ]]
	then
		echo "invalid arg: $arg"
		exit 1
	elif [[ -f "$arg" ]]
	then
		files+=("$arg")
	elif [[ -d "$arg" ]]
	then
		# add files in the dir to our list of files
		readarray -d '' files < <(find "$arg" -type f -print0 -not -ipath '*/.git/*')
	else
		echo 'invalid path'
		exit 1
	fi
done


# add pipe args to the list of regular args
if [ ! -t 0 ]
then
	readarray pipeArgs < /dev/stdin
	files+=( "${pipeArgs[@]}" )
fi

# iterate over args
for file in "${files[@]}"
do
	# skip empty args
	if [[ -z "$file" ]]
	then
		continue
	elif [[ ! -f "$file" ]]
	then
		echo "file does not exist: $file"
		continue
	fi

	fileType="$(file --brief --mime-type "$file" | cut -d '/' -f1)"

	# skip non text files
	if [[ "$fileType" != "text" ]]
	then
		continue
	fi

	if [[ "$optTw" == 1 ]] && grep -Piq '[ \t]+$' "$file"
	then
		perl -i -pe 's/[ \t]+$//g' "$file"
	elif [[ "$optCarriageReturn" == 1 ]] && grep -q --binary $'\r' "$file"
	then
		perl -i -pe 's/\r//g' "$file"
	elif [[ "$optTab" == 1 ]] && grep -Piq '^\W*?\t+?\W*?\w' "$file"
	then
		# tempPath="$(mktemp)"
		# expand -i -t 4 "$file" > "$tempPath" && mv "$tempPath" "$file"
		:
	elif [[ "$optCommentSpacing" == 1 ]]
	then
		fileExt="${file##*.,,}"
		if [[ "$fileExt" == "cs" ]]
		then
			commentChar="\\\\"
		elif [[ "$fileExt" == "sql" ]]
		then
			commentChar="--"
		else
			# using # for the default comment char, so no need to test for bash scripts
			commentChar="\#"
		fi

		perl -i -pe "s@(?<=[^${commentChar}])${commentChar}(?=[^ !\$${commentChar}])@${commentChar} @g" "$file"
		perl -i -pe "s@(?<=^)${commentChar}(?=[^ !\$${commentChar}])@${commentChar} @g" "$file"
	fi

done
