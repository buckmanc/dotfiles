#!/usr/bin/env bash

set -e

lastHeader=''
lastContent=''
optAll=0
optShort=0
optNew=0
optSpeak=0
optQuiet=0
reverseJqArg=" | reverse"
# ltr mark, pop directional formatting, ltr embedding
dumpCharRegex='(\xE2\x80\x8E|\xE2\x80\xAC|\xE2\x80\xAA)'

cacheDir="$HOME/.log"
lastCheckPath="$cacheDir/termux-notification-read.log"
mkdir -p "$cacheDir"

if [[ -f "$lastCheckPath" ]]
then
	lastCheckStamp="$(date --reference "$lastCheckPath" '+%s')"
else
	lastCheckStamp=0
fi

for arg in "$@"
do
	if [[ "$arg" == "--all" || "$arg" == "-a" ]]
	then
		optAll=1
	elif [[ "$arg" == "-r" || "$arg" == "--reverse" ]]
	then
		# reverseJqArg=" | reverse"
		reverseJqArg=''
	elif [[ "$arg" == "-s" || "$arg" == "--short" ]]
	then
		optShort=1
	elif [[ "$arg" == "--new" ]]
	then
		optNew=1
	elif [[ "$arg" == "--speak" || "$arg" == "--read" ]]
	then
		optSpeak=1
	elif [[ "$arg" == "--quiet" ]]
	then
		optQuiet=1
	else
		echo "I have no idea what $arg means"
		exit 1
	fi
done

# time considerations in jq aren't working
# seems like jq is introducing a timezone problem, despite both times being local

# selecting only the fields we want and piping to uniq
# to remove sequential logical dupes
# ddjsonList="$(termux-notification-list | jq "sort_by(.when) $reverseJqArg" | jq -rc ".[] | select((.when | strptime(\"%Y-%m-%d %H:%M:%S\") | mktime) > $targetEpochSec) | {packageName, title, content}" | uniq)"
# jsonList="$(termux-notification-list | jq "sort_by(.when) $reverseJqArg" | jq -rc ".[] | {packageName, title, content}" | uniq)"
nabStamp="@$(date '+%s')"
jsonList="$(termux-notification-list | jq -rc "group_by(.packageName, .title, .content) | map(max_by(.when)) | sort_by(.when) $reverseJqArg | .[] | {packageName, title, content, when}" | uniq)"

while read -r json
do
	notiTimeStamp="$(echo "$json" | jq -r '.when')"

	# if showing new only, skip if old
	if [[ "$optNew" == 1 && "$(date --date "$notiTimeStamp" '+%s')" -lt "$lastCheckStamp" ]]
	then
		continue
	fi

	packageName="$(echo "$json" | jq -r '.packageName')"
	packageName="$(echo "$packageName" | perl -p \
		-e 's/^((org|com|android|samsung|google|apps|schabi|app|mobi|de|danoeh|app|sec|cliffweitzman|jrtstudio|lockdown|scee|kids|ballistiq|providers)\.)+//g;' \
		-e 's/^(facebook.orca)$/messenger/g;' \
		-e 's/^(oceanwing.care.cam)$/eufy Baby/g;' \
		-e 's/^(zhiliaoapp.musically)$/tiktok/g;' \
		-e 's/^(instagram.barcelona)$/threads/g;' \
		-e 's/^(daemonapp)$/weather/g;' \
		-e 's/^(gm)$/gmail/g;' \
		-e 's/^(tycho)$/googlefi/g;' \
		-e 's/^(vending)$/googleplay/g;' \
		-e 's/(\.(orca|android|frontpage|application|mShop|shopping|katana|music))+$//g;' \
		| cat)"

	title="$(echo "$json" | jq -r '.title' | perl -pe "s/$dumpCharRegex//g")"
	content="$(echo "$json" | jq -r '.content' | perl -pe "s/$dumpCharRegex//g")"

	if [[ "${packageName,,}" == "${title,,}" ]]
	then
		title=''
	fi

	# skip these no matter what
	if [[ "${packageName,,}" =~ ^(termux|spotify|aimp.player|newpipe|smartcapture|antennapod|systemui|samsungapps|speechify2?|anothermusicplayer)$ ]]
	then
		continue
	# skip bupkiss
	elif [[ -z "$title" && -z "$content" ]]
	then
		continue
	# skip these unless passed --all
	# things you might want to check once
	elif [[ "$optAll" == 0 ]]
	then
		if [[ "$packageName" =~ ^(termux.api|reddit|patreon|facebook|lool|tiktok|weather|truebill|walmart|jimmyjohns|psxandroid|youtube|vvm|scloud|downloads)$ ]]
		then
			continue
		elif [[ "$packageName" == "discord" ]] && [[ "$title" == *#memes* ]] && [[ "${content,,}" =~ \.(jpe?g|png|mp4)$ || "${content,,}" =~ ^http.+(youtu\.?be|tiktok) || "${content,,}" =~ ^reacted.+to\ your ]]
		then
			continue
		elif [[ "$packageName" == "snapchat" ]] && [[ "${content,,}" == *'added a video to spotlight!' || "${content,,}" == *"is on snapchat!" || "${content,,}" == *"added to their story"* || "${content,,}" == "updating messages"* || "${content,,}" == *"new friend suggestion"* ]]
		then
			continue
		elif [[ "$packageName" == "photos" ]] && [[ "${title,,}" == 'we made a collage'* ]]
		then
			continue
		elif [[ "$packageName" == "dropbox" ]] && [[ "${title,,}" == 'changes saved' ]]
		then
			continue
		elif [[ "$packageName" == "messaging" ]]
		then
			if [[ "${content,,}" =~ (text|reply)(\ \"?(start|help)\"?\ for\ (help|consent)\ and)?\ \"?(stop|cancel)\"?\ to\ (cancel|stop|opt[\ \-]out|unsubscribe|unsub|decline) ]]
			then
				continue
			elif [[ "${content,,}" == *"new voicemail from"*  && "${content,,}" == *"no transcript available"* ]]
			then
				continue
			elif [[ "${content,,}" =~ visit\ http ]]
			then
				continue
			elif [[ "${content,,}" =~ (department|group|unit|desk) ]]
			then
				if echo "$content" | grep -qiP 'this( message)? is ?[^\.]* from the [^\.]+ (department|group|unit|desk)'
				then
					continue
				fi
			fi
		elif [[ "$packageName" == "instagram" ]] && [[ "${content,,}" == *'who you might know, is on instagram'* || "${content,,}" == *"reposted"* ]]
		then
			continue
		elif [[ "$packageName" == "threads" ]] && [[ "${title,,}" == *suggested* ]]
		then
			continue
		elif [[ "$packageName" == "youtube" ]] && [[ "${content,,}" == 'for you:'* ]]
		then
			continue
		elif [[ "$packageName" == "amazon" ]] && [[ "${title,,}" == *'see where your package is'* || "${title,,}" == *'out for delivery'* || "${title,,}" == "new from"* ]]
		then
			continue
		elif [[ "$packageName" == "amazon" ]] && [[ "${title,,}" =~ (^get this|deals) && "${content,,}" =~ (shop|save) ]]
		then
			continue
		elif [[ "$packageName" == "googleplay" ]] && [[ "${content,,}" == *'successfully installed'* ]]
		then
			continue
		elif [[ "$packageName" == "nextdoor" ]] && [[ "${content,,}" == *'reposted'* || "${title,,}" == "updates you may have missed" ]]
		then
			continue
		elif [[ "${packageName,,}" == "dialer" && "${content,,}" == "suspected spam" ]]
		then
			continue
		elif [[ "${content,,}" == *"a new login was detected"* ]]
		then
			continue
		fi
	fi

	# app specific tweaks
	if [[ "${packageName,,}" == "facebook" ]]
	then
		acct="$title"
		title=""
		if [[ "$content" != *"$acct"* ]]
		then
			content="$acct: $content"
		fi
	elif [[ "${packageName,,}" == "messaging" ]] && [[ "$title" == *,* ]]
	then
		mostCommonWord="$(echo "$title" | grep -iPo '\b\w+\b' | sort | uniq -ci | sort -h | tail -n1 | sed 's/^ *[0-9]* //g')"
		
		title="$mostCommonWord group"
	fi
	
	header="$packageName: $title"
	if [[ "$header" != "$lastHeader" ]]
	then
		if [[ "$optShort" == 0 ]]
		then
			output+=$'\n'
		fi
		output+="--------"$'\n'
		if [[ "$optShort" == 0 ]]
		then
			output+=$'\n'
		fi
		output+="$header"$'\n'

		lastHeader="$header"
	fi

	if [[ -n "$content" ]]
	then
		if [[ "$header" == "$lastHeader" ]]
		then
			# if the previous content starts with this one, skip
			if [[ "$lastContent" == "$content"* ]]
			then
				continue
			# if this content starts with the previous content, remove the previous content
			elif [[ -n "$lastContent" && "$content" == "$lastContent"* ]]
			then
				# gotta manually re-add that trailing new line because "echo" removes it
				output="$(echo "$output" | perl -0777pe 's/(?<=\n)[^\n]+\n$/\n\n/g')"$'\n'
			fi
		fi
		output+="$content"$'\n'

		lastContent="$content"
	fi
	
done < <( echo "$jsonList" )

output="$(echo "$output" | perl -0777pe 's/(^[\s-]+|[\s-]+$)//g')"

screenHeight=$(($(tput lines)-3))
outputHeight="$(echo "$output" | wc -l)"

# echo "screenHeight: $screenHeight"
# echo "outputHeight: $outputHeight"

# update the last check file with the stamp of just before notifications were nabbed
# doing it here in case of errors between here and there
touch --date "$nabStamp" "$lastCheckPath"

if [[ -z "$output" ]]
then
	output="no notifications"
	# centerPath="$HOME/bin/center"
	# if [[ -x "$centerPath" ]]
	# then
	# 	output="$(echo "$output" | "$centerPath")"
	# fi

	if (type lolcat > /dev/null 2>&1)
	then
		output="$(echo "$output" | lolcat)"
	fi

	if [[ "$optQuiet" == 0 ]]
	then
		echo "$output"
	fi
	
# do our own --quit-if-one-screen calc
# to allow for prompt height
elif [[ -n "$output" ]]
then
	if [[ "$optSpeak" == 1 ]]
	then
		(echo "$output" | termux-tts-speak &)
	fi

	if [[ "$outputHeight" -gt "$screenHeight" ]]
	then
		echo "$output" | less
	# elif [[ "$outputHeight" -eq "$screenHeight" ]]
	# then
	# 	echo -n "$output"
	else
		echo "$output"
	fi
fi
