#!/usr/bin/env bash

lastHeader=''
lastContent=''
optAll=0
reverseJqArg=" | reverse"
# ltr mark, pop directional formatting, ltr embedding
dumpCharRegex='(\xE2\x80\x8E|\xE2\x80\xAC|\xE2\x80\xAA)'

for arg in "$@"
do
	if [[ "$arg" == "--all" || "$arg" == "-a" ]]
	then
		optAll=1
	elif [[ "$arg" == "-r" || "$arg" == "--reverse" ]]
	then
		# reverseJqArg=" | reverse"
		reverseJqArg=''
	fi
done

# use regex replace to support sleep syntax
# 1s, 1h, 1m, 1d etc
# final line formats unknown parameters
# allowing for month, year, etc
dateInput=$(echo "$*" \
	| grep -iPo '\b\d+ ?[a-zA-Z]+(?=\d| |$)' \
	| perl -p \
	-e 's/(\d+)s(?=\d| |$)/\1second /g;' \
	-e 's/(\d+)m(?=\d| |$)/\1minute /g;' \
	-e 's/(\d+)h(?=\d| |$)/\1hour /g;' \
	-e 's/(\d+)d(?=\d| |$)/\1day /g;' \
	-e 's/(\d+)w(?=\d| |$)/\1week /g;' \
	-e 's/(\d+[a-zA-Z]+)(?=\d| |$)/\1 /g;'
)

if [[ -n "$dateInput" ]]
then
	startEpochSec=$(date +"%s")
	futureEpochSec=$(date --date="$dateInput" +"%s")
	secInPast="$((futureEpochSec-startEpochSec))"
	targetEpochSec="$((startEpochSec-secInPast))"
else
	# secInPast=$((365*24*60*60))
	targetEpochSec=0
fi

# echo "dateInput: $dateInput"
# echo "secInPast: $secInPast"
# echo "targetEpochSec: $targetEpochSec"

# right now this doesn't work
# seems like jq is introducing a timezone problem, despite both times being local

# selecting only the fields we want and piping to uniq
# to remove sequential logical dupes
jsonList="$(termux-notification-list | jq "sort_by(.when) $reverseJqArg" | jq -rc ".[] | select((.when | strptime(\"%Y-%m-%d %H:%M:%S\") | mktime) > $targetEpochSec) | {packageName, title, content}" | uniq)"

while read -r json
do
	packageName="$(echo "$json" | jq -r '.packageName')"
	packageName="$(echo "$packageName" | perl -p \
		-e 's/^((org|com|android|samsung|google|apps|schabi|app|mobi|de|danoeh|app|sec|cliffweitzman|jrtstudio|lockdown|scee)\.)+//g;' \
		-e 's/^(facebook.orca)$/messenger/g;' \
		-e 's/^(zhiliaoapp.musically)$/tiktok/g;' \
		-e 's/^(gm)$/gmail/g;' \
		-e 's/(\.(orca|android|frontpage|application|mShop|shopping|katana|music))+$//g;' \
		| cat)"

	title="$(echo "$json" | jq -r '.title' | perl -pe "s/$dumpCharRegex//g")"
	content="$(echo "$json" | jq -r '.content' | perl -pe "s/$dumpCharRegex//g")"

	if [[ "${packageName,,}" == "${title,,}" ]]
	then
		title=''
	fi

	# skip these no matter what
	if [[ "${packageName,,}" =~ ^(termux|spotify|aimp.player|newpipe|smartcapture|antennapod|systemui|samsungapps|speechify2?|anothermusicplayer)$ ]]
	then
		continue
	# skip bupkiss
	elif [[ -z "$title" && -z "$content" ]]
	then
		continue
	# skip these unless passed --all
	# things you might want to check once
	elif [[ "$optAll" == 0 ]]
	then
		if [[ "$packageName" =~ ^(termux.api|reddit|patreon|facebook|lool|tiktok|weather|truebill|walmart|jimmyjohns|psxandroid|youtube|vvm|scloud)$ ]]
		then
			continue
		elif [[ "$packageName" == "discord" ]] && [[ "$title" == *#memes* ]] && [[ "${content,,}" =~ \.(jpe?g|png)$ || "${content,,}" =~ ^http.+(youtu\.?be|tiktok) ]]
		then
			continue
		elif [[ "$packageName" == "snapchat" ]] && [[ "${content,,}" == *'added a video to spotlight!' || "${content,,}" == *"is on snapchat!" || "${content,,}" == *"added to their story"* || "${content,,}" == "updating messages"* ]]
		then
			continue
		elif [[ "$packageName" == "photos" ]] && [[ "${title,,}" == 'we made a collage'* ]]
		then
			continue
		elif [[ "$packageName" == "dropbox" ]] && [[ "${title,,}" == 'changes saved' ]]
		then
			continue
		elif [[ "$packageName" == "messaging" ]] && [[ "${content,,}" =~ (text|reply)(\ \"?(start|help)\"?\ for\ (help|consent)\ and)?\ \"?(stop|cancel)\"?\ to\ (cancel|stop|opt[\ \-]out|unsubscribe|unsub|decline) ]]
		then
			continue
		elif [[ "$packageName" == "messaging" && "${content,,}" == *department* ]]
		then
			firstSentence="$(echo "$content" | grep -iPo '^[^\.\r\n]+\.' | head -n1)"
			if echo "$firstSentence" | grep -qiP 'this is .+ from the .+ department'
			then
				continue
			fi
		elif [[ "$packageName" == "instagram" ]] && [[ "${content,,}" == *'who you might know, is on instagram'* || "${content,,}" == *"reposted"* ]]
		then
			continue
		elif [[ "$packageName" == "youtube" ]] && [[ "${content,,}" == 'for you:'* ]]
		then
			continue
		elif [[ "$packageName" == "amazon" ]] && [[ "${title,,}" == *'see where your package is'* ]]
		then
			continue
		elif [[ "$packageName" == "nextdoor" ]] && [[ "${content,,}" == *'reposted'* || "${title,,}" == "updates you may have missed" ]]
		then
			continue
		elif [[ "${content,,}" == *"a new login was detected"* ]]
		then
			continue
		fi
	fi

	# app specific tweaks
	if [[ "${packageName,,}" == "facebook" ]]
	then
		acct="$title"
		title=""
		if [[ "$content" != *"$acct"* ]]
		then
			content="$acct: $content"
		fi
	elif [[ "${packageName,,}" == "messaging" ]] && [[ "$title" == *,* ]]
	then
		mostCommonWord="$(echo "$title" | grep -iPo '\b\w+\b' | sort | uniq -ci | sort -h | tail -n1 | sed 's/^ *[0-9]* //g')"
		
		title="$mostCommonWord group"
	fi
	
	header="$packageName: $title"
	if [[ "$header" != "$lastHeader" ]]
	then
		output+=$'\n'
		output+="--------"$'\n'
		output+=$'\n'
		output+="$header"$'\n'

		lastHeader="$header"
	fi

	if [[ -n "$content" ]]
	then
		if [[ "$header" == "$lastHeader" ]]
		then
			# if the previous content starts with this one, skip
			if [[ "$lastContent" == "$content"* ]]
			then
				continue
			# if this content starts with the previous content, remove the previous content
			elif [[ -n "$lastContent" && "$content" == "$lastContent"* ]]
			then
				# gotta manually re-add that trailing new line because "echo" removes it
				output="$(echo "$output" | perl -0777pe 's/(?<=\n)[^\n]+\n$/\n\n/g')"$'\n'
			fi
		fi
		output+="$content"$'\n'

		lastContent="$content"
	fi
	
done < <( echo "$jsonList" )

output="$(echo "$output" | perl -0777pe 's/(^[\s-]+|[\s-]+$)//g')"

screenHeight=$(($(tput lines)-3))
outputHeight="$(echo "$output" | wc -l)"

# echo "screenHeight: $screenHeight"
# echo "outputHeight: $outputHeight"

if [[ -z "$output" ]]
then
	output="no notifications"
	# centerPath="$HOME/bin/center"
	# if [[ -x "$centerPath" ]]
	# then
	# 	output="$(echo "$output" | "$centerPath")"
	# fi

	if (type lolcat > /dev/null 2>&1)
	then
		output="$(echo "$output" | lolcat)"
	fi

	echo "$output"
	
# do our own --quit-if-one-screen calc
# to allow for prompt height
elif [[ -n "$output" ]]
then
	if [[ "$outputHeight" -gt "$screenHeight" ]]
	then
		echo "$output" | less
	# elif [[ "$outputHeight" -eq "$screenHeight" ]]
	# then
	# 	echo -n "$output"
	else
		echo "$output"
	fi
fi
